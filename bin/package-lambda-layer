#!/bin/bash
set -e

SRC=src
OUTPUT=Lambda.zip
EXCLUDE_PACKAGES=""
BUILD_DIR=$PWD/build
IS_LAYER=0
TMP_DIR=$BUILD_DIR/tmp/
PYPI_URL=
PYTHON_VERSION=3.13

# Parse named parameters
while [ $# -gt 0 ]; do
    if [[ $1 == *"="* ]]; then
        # Handle --param=value style
        param="${1%%=*}"
        value="${1#*=}"

        case "$param" in
            --src)
                SRC="$value"
                ;;
            --output)
                OUTPUT="$value"
                ;;
            --build)
                BUILD_DIR="$value"
                ;;
            --exclude)
                EXCLUDE_PACKAGES="$value"
                ;;
            --pypi)
                PYPI_URL="$value"
                ;;
            --layer)
                IS_LAYER=1
                ;;
            --python-version)
                PYTHON_VERSION="$value"
                ;;
            *)
                echo "Unknown parameter: $param"
                echo "Usage: $0 --src <source_dir> --output <output_file> --exclude <packages> --layer --python-version <version>"
                exit 1
                ;;
        esac
    else
        # Handle --param value style
        case "$1" in
            --src)
                shift
                SRC="$1"
                ;;
            --output)
                shift
                OUTPUT="$1"
                ;;
            --build)
                shift
                BUILD_DIR="$1"
                TMP_DIR=$BUILD_DIR/tmp/python/
                ;;
            --exclude)
                shift
                EXCLUDE_PACKAGES="$1"
                ;;
            --pypi)
                shift
                PYPI_URL="$1"
                ;;
            --layer)
                IS_LAYER=1
                ;;
            --python-version)
                shift
                PYTHON_VERSION="$1"
                ;;
            *)
                echo "Unknown parameter: $1"
                echo "Usage: $0 --src <source_dir> --output <output_file> --exclude <packages> --layer --python-version <version>"
                exit 1
                ;;
        esac
    fi
    shift
done

echo "Starting"
if [ $IS_LAYER -eq 1 ]; then
    TMP_DIR=$BUILD_DIR/tmp/python/
fi

if [ -z "$PYPI_URL" ]; then
    echo "Must supply PYPI_URL via --pypi"
    exit 1
fi

# Extract IP from PYPI_URL for trusted host
TRUSTED_HOST=$(echo $PYPI_URL | sed 's|http://||' | sed 's|/.*||')

# Print parameters for debugging
echo "Source directory: $SRC"
echo "Output file: $OUTPUT"
echo "Build directory: $BUILD_DIR"
echo "Temp directory: $TMP_DIR"
echo "Python version: $PYTHON_VERSION"

# Use AL2023 container image for Lambda-compatible builds
# This ensures native extensions are compiled for the correct platform
# In Peru builds, use run-podman; locally fall back to docker
PYTHON_IMAGE="public.ecr.aws/sam/build-python${PYTHON_VERSION}:latest"

# Detect container runtime - prefer docker for reliability
# run-podman requires PODMAN_HOME or /apollo/env/podman which may not exist on dev desktops
if command -v docker &> /dev/null; then
    CONTAINER_CMD="docker"
elif command -v run-podman &> /dev/null && [[ -n "${PODMAN_HOME:-}" || -d "/apollo/env/podman" ]]; then
    CONTAINER_CMD="run-podman"
elif command -v podman &> /dev/null; then
    CONTAINER_CMD="podman"
else
    echo "ERROR: No container runtime found. Cannot build Lambda layers with native extensions."
    echo "For local builds, ensure Docker is installed."
    echo "In Peru builds with run-podman, set PODMAN_HOME or ensure /apollo/env/podman exists."
    exit 1
fi

install_requirements() {
    echo "Installing requirements using container (AL2023)..."
    rm -rf "$TMP_DIR" 2>/dev/null || sudo rm -rf "$TMP_DIR" 2>/dev/null || true
    mkdir -p "$TMP_DIR"

    if [ -f "$SRC/requirements.txt" ]; then
        echo "Installing requirements from $SRC/requirements.txt"
        echo "Using container image: $PYTHON_IMAGE"
        echo "Using container command: $CONTAINER_CMD"

        # Get absolute paths for container volume mounts
        ABS_SRC=$(cd "$SRC" && pwd)
        ABS_TMP=$(cd "$TMP_DIR" && pwd)

        # Get current user's UID/GID for ownership fix
        CURRENT_UID=$(id -u)
        CURRENT_GID=$(id -g)

        # Run pip install inside AL2023 container, then fix ownership
        $CONTAINER_CMD run --rm \
            -v "$ABS_SRC:/var/task/src:ro" \
            -v "$ABS_TMP:/var/task/output" \
            -e PYPI_URL="$PYPI_URL" \
            -e TRUSTED_HOST="$TRUSTED_HOST" \
            -e TARGET_UID="$CURRENT_UID" \
            -e TARGET_GID="$CURRENT_GID" \
            "$PYTHON_IMAGE" \
            /bin/bash -c "
                pip install -r /var/task/src/requirements.txt \
                    --force-reinstall \
                    --no-cache-dir \
                    --target /var/task/output \
                    --index-url \$PYPI_URL \
                    --trusted-host \$TRUSTED_HOST && \
                chown -R \$TARGET_UID:\$TARGET_GID /var/task/output
            "
    else
        echo "No requirements.txt found in $SRC"
    fi
}

build_package() {
    echo "Building package"
    if [ -d "$SRC" ]; then
        rsync -av --exclude='build' --exclude='.hatch' --exclude='.venv' --exclude='requirements.txt' "$SRC/" "$TMP_DIR/"
    fi
}

package_artifacts() {
    echo "Packaging"
    if [ -n "$EXCLUDE_PACKAGES" ]; then
        echo "Removing excluded packages: $EXCLUDE_PACKAGES"
        for pkg in ${EXCLUDE_PACKAGES//,/ }; do
            echo "Removing $pkg"
            rm -rf ${TMP_DIR}/${pkg}
            rm -rf ${TMP_DIR}/${pkg}-*
            # Also remove egg-info directories
            find "$TMP_DIR" -type d -name "${pkg}*egg-info" -exec rm -rf {} +
        done
    fi

    # AWS Lambda recommends to exclude __pycache__: https://docs.aws.amazon.com/lambda/latest/dg/python-package.html#python-package-pycache
    find "${TMP_DIR}" -depth -name __pycache__ -exec rm -rf {} \;
    cd "${BUILD_DIR}/tmp/"
    zip -r "${BUILD_DIR}/${OUTPUT}" .
    rm -rf "${BUILD_DIR}/tmp"
}

install_requirements
build_package
package_artifacts
